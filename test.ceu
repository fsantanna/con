^["char.ceu"]

data :Pos = [lin,col]
data :Tk = [pos :Pos,str] {
    :Id  = []
    :Tag = []
    :Num = []
    :Sym = []
}

;;-----------------------------------------------------------------------------

func iter-file (f-name, tp) {
    val ^f-hand = `:pointer fopen($f-name.Dyn->Ncast.Vector.buf, "r")`
    coro () {
        val f = ^^f-hand
        defer {
            `fclose($f.Pointer);`
        }
        loop {
            val b = `:number fgetc($f.Pointer)`
        } until (b == `:number EOF`) {
            yield(to-char(b))
        }
    } thus {
        iter(it)
    }
}

do {
    println(:ITER-FILE)
    val itr :Iterator = iter-file("x.ceu")
    assert(itr.f(itr) == '1')
    assert(itr.f(itr) == ' ')
    assert(itr.f(itr) == '2')
    assert(itr.f(itr) == ' ')
    assert(itr.f(itr) == ';')
    ;;assert(false)
}

;;-----------------------------------------------------------------------------

data :Chr = [pos :Pos, c]
data :Buf = [prv :Chr, cur :Chr]

func buf-init () {
    [nil, [[1,0],nil]]
}

func f-read-c (f-itr :Iterator, buf :Buf) {
    if buf.prv {
        set buf.cur = buf.prv
        set buf.prv = nil
        buf.cur.c
    } else {
        val c = f-itr.f(f-itr)
        set buf.cur.c = c
        set buf.cur.pos = if (c == '\n')
            -> [buf.cur.pos.lin+1 , 0]
            -> [buf.cur.pos.lin   , buf.cur.pos.col+1]
        c
    }
}

func f-unread-c (buf :Buf) {
    assert(buf.prv == nil)
    set buf.prv = buf.cur
    set buf.cur = nil
    nil
}

do {
    println(:F-READ-UNREAD)
    val f-itr = iter-file("x.ceu")
    val buf   = buf-init()
    f-read-c(f-itr, buf) thus {
        assert(buf === [nil,[[1,1],'1']])
    }
    f-unread-c(buf) thus {
        assert(buf === [[[1,1],'1'],nil])
    }
    f-read-c(f-itr, buf) thus {
        assert(buf === [nil,[[1,1],'1']])
    }
    f-read-c(f-itr, buf) thus {
        assert(buf === [nil,[[1,2],' ']])
    }
    f-unread-c(buf) thus {
        assert(buf === [[[1,2],' '],nil])
    }
    f-read-c(f-itr, buf) thus {
        assert(buf === [nil,[[1,2],' ']])
    }
}

func f-read-until-f (f-itr, buf, f-pred) {
    val str = #[]
    loop {
        val c = f-read-c(f-itr, buf)
    } until f-pred(c) {
        set str[+] = c
    }
    move(str)
}

func f-read-until-c (f-itr, buf, c) {
    f-read-until-f(f-itr, buf, \{ it == c })
}

func f-read-while-f (f-itr, buf, f-pred) {
    defer {
        f-unread-c(buf)
    }
    f-read-until-f(f-itr, buf, \{ not f-pred(it) })
}

func f-read-while-c (f-itr, buf, c) {
    f-read-while-f(f-itr, buf, \{ it == c })
}

do {
    println(:F-READ-UNTIL)
    val f-itr = iter-file("x.ceu")
    val buf   = buf-init()
    f-read-until-c(f-itr, buf, ';') thus {
        assert(it === "1 2 ")
    }
    f-read-until-f(f-itr, buf, \{ it=='\n'}) thus {
        assert(it === "; 9")
    }
    f-read-while-f(f-itr, buf, \{ it /= ';' }) thus {
        assert(it === "3 ")
    }
    f-read-while-c(f-itr, buf, ';') thus {
        assert(it === ";;")
    }
}

;;-----------------------------------------------------------------------------

func iter-skip (^f-itr :Iterator, ^buf :Buf) {
    coro () {
        loop {
            val c = f-read-c(^^f-itr, ^^buf)
        } while c {
            ifs c {
                in? [' ','\t','\n'] {}
                == ';' {
                    val c' = f-read-c(^^f-itr, ^^buf)
                    if c' /= ';' {
                        f-unread-c(^^buf)
                    } else {
                        f-read-until-c(^^f-itr, ^^buf, '\n')
                    }
                }
                else -> yield(c)
            }
        }
    } thus {
        iter(it)
    }
}

do {
    println(:ITER-SKIP)
    val f-itr = iter-file("x.ceu")
    val buf   = buf-init()
    val s-itr :Iterator = iter-skip(f-itr, buf)
    s-itr.f(s-itr) thus {
        assert(it == '1')
    }
    s-itr.f(s-itr) thus {
        assert(it == '2')
    }
    s-itr.f(s-itr) thus {
        assert(it == '3')
    }
}

func iter-lexer (^skip :Iterator, ^file :Iterator, ^buf :Buf) {
    coro () {
        val SS :Iterator = ^^skip
        val FF :Iterator = ^^file
        val BB :Buf      = ^^buf
        loop {
            val c = SS.f(SS)
            val pos = copy(BB.cur.pos)
        } while c {
            ifs c {
                digit?(c) {              ;; NUM
                    f-unread-c(BB)
                    f-read-while-f(FF, BB, \{
                        (it == '.') or letter-or-digit?(it)
                    }) thus num {
                        yield(:Tk.Num [move(pos),num])
                    }
                }
                letter?(c) or (c=='_') { ;; KEY, ID
                    f-unread-c(BB)
                    f-read-while-f(FF, BB, \{
                        letter-or-digit?(it) or (it in? ['_','\'','?','!'])
                    }) thus id {
                        yield(:Tk.Id [move(pos),id])
                    }
                }
                else -> throw("invalid token")
            }
        }
    } thus {
        iter(it)
    }
}

do {
    println(:ITER-LEXER)
    val file  = iter-file("x.ceu")
    val buf   = buf-init()
    val skip  :Iterator = iter-skip(file, buf)
    val lexer :Iterator = iter-lexer(skip, file, buf)
    lexer.f(lexer) thus {
        assert(it === :Tk.Num [[1,1],"1"])
    }
    lexer.f(lexer) thus {
        assert(it === :Tk.Num [[1,3],"2"])
    }
    lexer.f(lexer) thus {
        assert(it === :Tk.Num [[2,1],"3"])
    }
    lexer.f(lexer) thus {
        assert(it === :Tk.Id  [[3,5],"abc"])
    }
}


