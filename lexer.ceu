data :Tk = [pos :Pos, str] {
    :Sym = []
    :Tag = []
    :Num = []
}

export [iter-lexer] {
    func iter-skip (^buf :Buffer) {
        coro () {
            loop {
                val c = buf-read-c(^^buf)
            } while c {
                ifs c {
                    in? [' ','\t','\n'] {}
                    == ';' {
                        val c' = buf-read-c(^^buf)
                        if c' /= ';' {
                            buf-unread-c(^^buf)
                        } else {
                            buf-read-until-c(^^buf, '\n')
                        }
                    }
                    else -> yield(c)
                }
            }
        } thus {
            iter(it)
        }
    }

    do {
        println(:ITER-SKIP)
        val buf = buf-init(iter("1 2 ;; 9\n3 ;;"))
        val skip :Iterator = iter-skip(buf)
        skip.f(skip) thus {
            assert(it == '1')
        }
        skip.f(skip) thus {
            assert(it == '2')
        }
        skip.f(skip) thus {
            assert(it == '3')
        }
    }

    func iter-lexer (^inp :Iterator) {
        coro () {
            val buf  :Buffer   = buf-init(^^inp)
            val skip :Iterator = iter-skip(buf)
            loop {
                val c = skip.f(skip)
                val pos = copy(buf.cur.pos)
            } while c {
                ifs c {
                    in? ['@','#','(',')','[',']',',','-'] {
                        yield(:Tk.Sym [move(pos), to-string(c)])
                    }
                    == ':' {                ;; TAG
                        buf-read-while-f(buf) \{
                            letter-or-digit?(it)
                        } thus tag {
                            yield(:Tk.Tag [move(pos), to-string(c) ++ tag])
                        }
                    }
                    {{digit?}} {              ;; NUM
                        buf-unread-c(buf)
                        buf-read-while-f(buf) \{
                            (it == '.') or letter-or-digit?(it)
                        } thus num {
                            yield(:Tk.Num [move(pos),move(num)])
                        }
                    }
                    else -> throw("invalid token")
                }
            }
        } thus {
            iter(it)
        }
    }

    do {
        println(:ITER-LEXER)
        val itr = iter-file("x.ceu")
        val lexer :Iterator = iter-lexer(itr)
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[1,1],"1"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[1,3],"2"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[2,1],"3"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Tag [[3,5],":x"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,1],"@"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,2],"["])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,3],"("])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[4,4],"10"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,6],","])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[4,7],"20"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,9],")"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,10],"]"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,12],"#"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,13],"["])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,14],"-"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[4,15],"1"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[4,16],","])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Num [[4,17],":x"])
        }
        lexer.f(lexer) thus {
            assert(it === :Tk.Sym [[4,19],"]"])
        }
    }
}
