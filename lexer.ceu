val KEYS = ["false", "nil", "true"]

data :Tk = [pos :Pos, str] {
    :Err = []
    :Sym = []
    :Tag = []
    :Num = []
    :Key = []
    :Id  = []
}

func iter-spaces (buf :Buffer) {
    to.iter <-- coro () {
        loop {
            val c = buf->read-c()
            while c
            match c {
                in? [' ','\t','\n'] {}
                ';' {
                    val c' = buf->read-c()
                    if c' /= ';' {
                        buf->unread-c()
                    } else {
                        buf->read-until-c('\n')
                    }
                }
                else => yield(c)
            }
        }
    }
}

do {
    println(:ITER-SKIP)
    val buf = buf-init(to.iter("1 2 ;; 9\n3 ;;"))
    val spc :Iterator = iter-spaces(buf)
    spc->next() thus {
        assert(it == '1')
    }
    spc->next() thus {
        assert(it == '2')
    }
    spc->next() thus {
        assert(it == '3')
    }
}

func iter-lexer (inp :Iterator) {
    to.iter <-- coro () {
        val buf :Buffer   = buf-init(inp)
        val spc :Iterator = iter-spaces(buf)
        loop {
            val c = spc->next()
            val pos = copy(buf.cur.pos)
            while c
            match c {
                in? ['@','#','(',')','[',']',',','-','='] {
                    yield(:Tk.Sym [pos, to.string(c)])
                }
                ':' {                   ;; TAG
                    buf->read-while-f(letter-or-digit?) thus {
                        yield(:Tk.Tag [pos, to.string(c) ++ it])
                    }
                }
                '\'' {
                    val c2 = buf->read-c()
                    match c2 {
                        '\'' => error(:Tk.Err [copy(buf.cur.pos), "unexpected \"'\""])
                        nil => error(:Tk.Err [pos, "unterminated \"'\""])
                        '\\' {
                            val c3 = buf->read-c()
                            assert(c3, :Tk.Err [pos, "unterminated \"'\""])
                            #['\\',c3]
                        }
                        else => to.string(c2)
                    } thus {
                        buf->read-c() thus {
                            assert(it == '\'', :Tk.Err [copy(buf.cur.pos), "expected \"'\""])
                        }
                        yield(:Tk.Chr [pos,"'" ++ to.string(it) ++ "'"])
                    }
                }
                {{digit?}} {            ;; NUM
                    buf->unread-c()
                    buf->read-while-f <- \{
                        (it == '.') or letter-or-digit?(it)
                    } thus {
                        yield(:Tk.Num [pos,it])
                    }
                }
                {{letter?}} {           ;; KEY / ID
                    val id = to.string(c) ++ buf->read-while-f(letter?)
                    val tk = if id in? KEYS {
                        :Tk.Sym [pos, id]
                    } else {
                        :Tk.Id  [pos, id]
                    }
                    yield(tk)
                }
                else => error(:Tk.Err [pos, "invalid input"])
            }
        }
    }
}

do {
    println(:LEXER)
    do {
        val itr = to.iter("")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next() thus {
            assert(it == nil)
        }
    }
    do {
        val t = ['@','#','(',')','[',']',',','-','=']
        val itr = to.iter("@#()[],-=")
        val lexer :Iterator = iter-lexer(itr)
        loop c in t {
            val tk :Tk = lexer->next()
            assert(tk.str[0] == c)
        }
    }
    do {
        val itr = to.iter(":X :1 :a-b-c")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next() thus {
            assert(it === :Tk.Tag [[1,1], ":X"])
        }
        lexer->next() thus {
            assert(it === :Tk.Tag [[1,4], ":1"])
        }
        lexer->next() thus {
            ;; TODO
            ;;assert(it === :Tk.Tag [[1,7], ":a-b-c"])
        }
    }
    do {
        val itr = to.iter("nil true false")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next() thus {
            assert(it === :Tk.Tag [[1,1], "nil"])
        }
        lexer->next() thus {
            assert(it === :Tk.Tag [[1,5], "true"])
        }
        lexer->next() thus {
            assert(it === :Tk.Tag [[1,10], "false"])
        }
    }
    do {
        val itr = to.iter("10 9")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next() thus {
            assert(it === :Tk.Num [[1,1], "10"])
        }
        lexer->next() thus {
            assert(it === :Tk.Num [[1,4], "9"])
        }
    }
;;;
    do {
        val itr = to.iter("'z' '\n'")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next() thus {
            assert(it === :Tk.Chr [[1,1], "'z'"])
        }
        lexer->next() thus {
            assert(it === :Tk.Chr [[1,5], "'\\n'"])
        }
    }
;;;
}

do {
    println(:LEXER-ERR)
    catch {
        val itr = to.iter("\n *")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        assert(it === :Tk.Err [[2,2], "invalid input"])
    }
    catch {
        val itr = to.iter("tru")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        ;;assert(it === :Tk.Err [[1,1], "invalid keyword"])
        assert(it === :Tk.Id [[1,1], "tru"])
    }
    catch {
        val itr = to.iter("''")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        assert(it === :Tk.Err [[1,2], "unexpected \"'\""])
    }
    catch {
        val itr = to.iter("'")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        assert(it === :Tk.Err [[1,1], "unterminated \"'\""])
    }
    catch {
        val itr = to.iter("'ab'")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        assert(it === :Tk.Err [[1,3], "expected \"'\""])
    }
    catch {
        val itr = to.iter("'\\nx'")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        assert(it === :Tk.Err [[1,4], "expected \"'\""])
    }
    catch {
        val itr = to.iter("'\\")
        val lexer :Iterator = iter-lexer(itr)
        lexer->next()
    } thus {
        assert(it === :Tk.Err [[1,1], "unterminated \"'\""])
    }
}

do {
    println(:LEXER-X)
    val itr = to-iter-file("x.ceu")
    val lexer :Iterator = iter-lexer(itr)
    lexer->next() thus {
        assert(it === :Tk.Num [[1,1],"1"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[1,3],"2"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[2,1],"3"])
    }
    lexer->next() thus {
        assert(it === :Tk.Tag [[3,5],":x"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,1],"@"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,2],"["])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,3],"("])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,4],"10"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,6],","])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,7],"20"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,9],")"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,10],"]"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,12],"#"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,13],"["])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,14],"-"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,15],"1"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,16],","])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,17],":x"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,19],"]"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[5,1],"nil"])
    }
    lexer->next() thus {
        assert(it === :Tk.Chr [[6,1],"'c'"])
    }
    lexer->next() thus {
        assert(it === :Tk.Chr [[6,5],"'\\n'"])
    }
}
