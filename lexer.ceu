val KEYS = ["false", "nil", "true"]

data :Tk = [pos :Pos, str] {
    :Sym = []
    :Tag = []
    :Num = []
}

func iter-spaces (buf :Buffer) {
    to-iter <-- coro () {
        loop {
            val c = buf->read-c()
            while c
            match c {
                in? [' ','\t','\n'] {}
                ';' {
                    val c' = buf->read-c()
                    if c' /= ';' {
                        buf->unread-c()
                    } else {
                        buf->read-until-c('\n')
                    }
                }
                else => yield(c)
            }
        }
    }
}

do {
    println(:ITER-SKIP)
    val buf = buf-init(to-iter("1 2 ;; 9\n3 ;;"))
    val spc :Iterator = iter-spaces(buf)
    spc->next() thus {
        assert(it == '1')
    }
    spc->next() thus {
        assert(it == '2')
    }
    spc->next() thus {
        assert(it == '3')
    }
}

func iter-lexer (inp :Iterator) {
    to-iter <-- coro () {
        val buf :Buffer   = buf-init(inp)
        val spc :Iterator = iter-spaces(buf)
        loop {
            val c = spc->next()
            val pos = copy(buf.cur.pos)
            while c
            match c {
                in? ['@','#','(',')','[',']',',','-'] {
                    yield(:Tk.Sym [pos, to-string(c)])
                }
                ':' {                   ;; TAG
                    buf->read-while-f(letter-or-digit?) thus {
                        yield(:Tk.Tag [pos, to-string(c) ++ it])
                    }
                }
                ;;'\'' { }
                {{digit?}} {            ;; NUM
                    buf->unread-c()
                    buf->read-while-f <- \{
                        (it == '.') or letter-or-digit?(it)
                    } thus {
                        yield(:Tk.Num [pos,it])
                    }
                }
                {{letter?}} {           ;; KEY
                    val key = to-string(c) ++ buf->read-while-f(letter?)
                    assert(key in? KEYS, :Tk.Err [pos, "invalid keyword"])
                    yield(:Tk.Sym [pos, key])
                }
                else => error(:Tk.Err [pos, "invalid character"])
            }
        }
    }
}

do {
    println(:ITER-LEXER)
    val itr = iter-file("x.ceu")
    val lexer :Iterator = iter-lexer(itr)
    lexer->next() thus {
        assert(it === :Tk.Num [[1,1],"1"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[1,3],"2"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[2,1],"3"])
    }
    lexer->next() thus {
        assert(it === :Tk.Tag [[3,5],":x"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,1],"@"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,2],"["])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,3],"("])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,4],"10"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,6],","])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,7],"20"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,9],")"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,10],"]"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,12],"#"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,13],"["])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,14],"-"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,15],"1"])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,16],","])
    }
    lexer->next() thus {
        assert(it === :Tk.Num [[4,17],":x"])
    }
    lexer->next() thus {
        assert(it === :Tk.Sym [[4,19],"]"])
    }
}
