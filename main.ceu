func iter-file (f-name, tp) {
    val f-ptr  = to-pointer(f-name)
    val f-hand = `:pointer fopen((char*)$f-ptr.Pointer, "r")`
    to-iter <-- coro () {
        val f = f-hand
        defer {
            `fclose($f.Pointer);`
        }
        loop {
            val b = `:number fgetc($f.Pointer)`
            until (b == `:number EOF`)
            yield(to-char(b))
        }
    }
}

do {
    println(:ITER-FILE)
    val itr :Iterator = iter-file("x.ceu")
    assert(itr->next() == '1')
    assert(itr->next() == ' ')
    assert(itr->next() == '2')
    assert(itr->next() == ' ')
    assert(itr->next() == ';')
    assert(itr->next() == ';')
    assert(itr->next() == ' ')
    assert(itr->next() == '9')
    assert(itr->next() == '\n')
    ;;assert(false)
}

^["char.ceu"]
^["buffer.ceu"]
^["lexer.ceu"]
^["tokens.ceu"]

;;-----------------------------------------------------------------------------

var con-parse

func con-list0 (tks :Tokens, sep, clo) {
    var vec = #[]
    loop {
        until tks->check-read(clo)
        set vec[#vec] = [con-parse(tks)]
        until tks->check-read(clo)
        while tks->error-read(sep)
    }

    val tup = tuple(#vec)
    loop v in to-iter(vec,:all) {
        set tup[v[0]] = v[1][0]
    }
    tup
}

set con-parse = func (tks :Tokens) {
    ifs {
        tks->check-read("nil")   { nil }
        tks->check-read("false") { false }
        tks->check-read("true")  { true }
        tks->check-read(:Tk.Num) { ,tk1 :Tk => to-number(tk1.str) }
        tks->check-read(:Tk.Tag) { ,tk2 :Tk => to-tag(tk2.str)   }
        tks->check-read("[")     { con-list0(tks, ",", "]") }
        tks->check-read("#") and
            tks->error-read("[") { to-vector(con-list0(tks, ",", "]")) }
    }
}

do {
    println(:CON)
    do {
        val tks = tks-init(to-iter("1"))
        val con = con-parse(tks)
        assert(con == 1)
    }
    do {
        val tks = tks-init(to-iter(":x"))
        val con = con-parse(tks)
        assert(con == :x)
        assert(to-string(con) === ":x")
    }
    do {
        val tks = tks-init(to-iter(":asdf"))
        val con = con-parse(tks)
        assert(con == nil)
    }
    do {
        val tks = tks-init(to-iter("[]"))
        val con = con-parse(tks)
        assert(con === [])
    }
    do {
        val tks = tks-init(to-iter("[1,2]"))
        val con = con-parse(tks)
        assert(con === [1,2])
    }
    do {
        val tks = tks-init(to-iter("[1,[9],2]"))
        val con = con-parse(tks)
        assert(con === [1,[9],2])
    }
    do {
        val tks = tks-init(to-iter("#[[1]]"))
        val con = con-parse(tks)
        assert(con === #[[1]])
    }
    do {
        val tks = tks-init(to-iter("nil"))
        val con = con-parse(tks)
        assert(con === nil)
    }
    do {
        val tks = tks-init(to-iter("false"))
        val con = con-parse(tks)
        assert(con === false)
    }
    do {
        val tks = tks-init(to-iter("true"))
        val con = con-parse(tks)
        assert(con === true)
    }
    catch {
        val tks = tks-init(to-iter("1"))
        tks->error-read("[")
    } thus {
        assert(it === tag(:Err, "error : expected \"[\" : have \"1\""))
    }
    catch {
        val tks = tks-init(to-iter("tre"))
        val con = con-parse(tks)
        assert(con === true)
    } thus {
        assert(it === :Tk.Err [[1,1],"invalid keyword"])
    }
}
